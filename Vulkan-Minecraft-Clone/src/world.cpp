#include "world.hpp"

#include <cassert>
#include <iostream>
#include <thread>
#include <unordered_set>

const ChunkCenter World::posToChunkCenter(const glm::vec3& pos) const
{
    const float fp_chunk_size = static_cast<float>(chunkSize);
    const float stride = fp_chunk_size;
    const float x = std::floor((pos.x + 0.5f) / fp_chunk_size + 0.5f) * stride;
    const float y = std::floor((pos.y + 0.5f) / fp_chunk_size + 0.5f) * stride;
    const float z = std::floor((pos.z + 0.5f) / fp_chunk_size + 0.5f) * stride;
    return ChunkCenter(x, y, z);
}

void World::runChunkLoadedCallbacks(const Chunk& chunk)
{
    for (const auto& callback : chunkLoadedCallbacks)
    {
        callback(chunk);
    }
}

void World::runChunkUnloadedCallbacks(const Chunk& chunk)
{
    for (const auto& callback : chunkUnloadedCallbacks)
    {
        callback(chunk);
    }
}

bool World::isChunkActive(const ChunkCenter& cc) const
{
    return activeChunks.contains(cc) && (activeChunks.at(cc) != nullptr);
}

World::World(const unsigned seed, const int chunk_size) : terrainHeightNoise(seed), seed(seed), chunkSize(chunk_size)
{
    // Set up noises.
    terrainHeightNoise.SetNoiseType(FastNoiseLite::NoiseType_OpenSimplex2S);
    terrainHeightNoise.SetFractalType(FastNoiseLite::FractalType_FBm);
    terrainHeightNoise.SetFractalOctaves(5);
    terrainHeightNoise.SetFractalWeightedStrength(1.5f);
}

World::~World()
{
    for (auto& chunk : chunks)
    {
        free(chunk.second);
    }
}

void World::init(const glm::vec3& origin, const unsigned radius)
{
    std::cout << ">>> Loading world with seed (" << seed << ")..." << std::endl;

    const unsigned total_num_chunks = updateChunks(origin, radius);

    // Report an update every second.
    do
    {
        std::cout << "  Loaded " << (total_num_chunks - chunksToAdd.size()) << "/" << total_num_chunks << " chunks."
                  << std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(1));
    } while (!chunksToAdd.empty());

    std::cout << "  Loaded " << (total_num_chunks - chunksToAdd.size()) << "/" << total_num_chunks << " chunks."
              << std::endl;

    std::cout << ">>> Finished loading world!" << std::endl;
}

std::optional<glm::vec3> World::getReachableBlock(const Ray& ray, glm::ivec3* face_entered)
{
    std::lock_guard<std::mutex> lock(updateChunksMutex);

    std::optional<glm::vec3> reachable_block_pos;

    // Under the assumption that the player's reach is never infinity.

    // Check the chunk that contains the ray's origin (the player's position).
    const ChunkCenter cc = posToChunkCenter(ray.getOrigin());
    if (isChunkActive(cc))
    {
        reachable_block_pos = activeChunks[cc]->getReachableBlock(ray, face_entered);
    }
    if (reachable_block_pos.has_value())
    {
        return reachable_block_pos;
    }

    // Check the chunk that contains the ray's direction at its max distance (where the player is looking).
    const ChunkCenter next_cc = posToChunkCenter(ray.getOrigin() + ray.getDirection() * ray.getMax());
    if (next_cc == cc)
    {
        return reachable_block_pos;
    }
    if (isChunkActive(next_cc))
    {
        reachable_block_pos = activeChunks[next_cc]->getReachableBlock(ray, face_entered);
    }

    return reachable_block_pos;
}

void World::addChunk(const std::vector<glm::vec3> chunk_centers)
{
    for (const auto& chunk_center : chunk_centers)
    {
        // Don't generate the chunk if it was already generated by another thread.
        if (chunks.contains(chunk_center))
        {
            continue;
        }

        Chunk* chunk = new Chunk(terrainHeightNoise, chunk_center, chunkSize);

        {
            std::lock_guard<std::mutex> lock(updateChunksMutex);
            chunks.emplace(chunk_center, chunk);
            activeChunks.emplace(chunk_center, chunks[chunk_center]);
            chunksToAdd.erase(chunk_center);
        }

        runChunkLoadedCallbacks(*chunks[chunk_center]);
    }
}

unsigned World::updateChunks(const glm::vec3& origin, const unsigned radius)
{
    // TODO: change to update in 3D.
    // Load all chunks visible to the player.
    const int render_distance = static_cast<int>(radius);
    const float offset = static_cast<float>(render_distance * chunkSize);

    std::unordered_set<ChunkCenter> inactive_chunks;
    for (const auto& entry : activeChunks)
    {
        inactive_chunks.emplace(entry.first);
    }

    std::vector<ChunkCenter> chunk_centers;

    float x = origin.x - offset;
    for (int i = 0; i <= (render_distance * 2); ++i)
    {
        float y = origin.y - offset;
        for (int j = 0; j <= (render_distance * 2); ++j)
        {
            float z = origin.z - offset;
            for (int k = 0; k <= (render_distance * 2); ++k)
            {
                const ChunkCenter cc = posToChunkCenter({x, y, z});
                inactive_chunks.erase(cc);
                if (!activeChunks.contains(cc))
                {
                    if (!chunks.contains(cc))
                    {
                        if (!chunksToAdd.contains(cc))
                        {
                            // Create the chunk asynchrounously and add it later.
                            chunksToAdd.emplace(cc);
                            chunk_centers.emplace_back(cc);
                        } // Else, do nothing.
                    }
                    else
                    {
                        activeChunks.emplace(cc, chunks[cc]);
                        if (isChunkActive(cc))
                        {
                            runChunkLoadedCallbacks(*activeChunks[cc]);
                        }
                    }
                }
                z += chunkSize;
            }
            y += chunkSize;
        }
        x += chunkSize;
    }

    if (!chunk_centers.empty())
    {
        // Give a batch of chunks to a single async thread to process.
        // TODO: use thread pool to avoid overhead.
        std::thread(&World::addChunk, this, chunk_centers).detach();
    }

    {
        std::lock_guard<std::mutex> lock(updateChunksMutex);

        // Remove now inactive chunks.
        for (const auto& cc : inactive_chunks)
        {
            if (isChunkActive(cc))
            {
                runChunkUnloadedCallbacks(*activeChunks[cc]);
            }
            activeChunks.erase(cc);
        }
    }

    return static_cast<unsigned>(chunk_centers.size());
}

void World::addBlock(const glm::vec3 block_pos)
{
    std::vector<glm::vec3> offsets = {
        glm::vec3(0.0f, 0.0f, 0.0f),
        glm::vec3(1.0f, 0.0f, 0.0f),
        glm::vec3(-1.0f, 0.0f, 0.0f),
        glm::vec3(0.0f, 1.0f, 0.0f),
        glm::vec3(0.0f, -1.0f, 0.0f),
        glm::vec3(0.0f, 0.0f, 1.0f),
        glm::vec3(0.0f, 0.0f, -1.0f),
    };
    for (const auto& offset : offsets)
    {
        const ChunkCenter cc = posToChunkCenter(block_pos + offset);
        if (isChunkActive(cc))
        {
            activeChunks[cc]->addBlock(block_pos);
            runChunkLoadedCallbacks(*activeChunks[cc]);
        }
    }
}

void World::removeBlock(const glm::vec3 block_pos)
{
    std::vector<glm::vec3> offsets = {
        glm::vec3(0.0f, 0.0f, 0.0f),
        glm::vec3(1.0f, 0.0f, 0.0f),
        glm::vec3(-1.0f, 0.0f, 0.0f),
        glm::vec3(0.0f, 1.0f, 0.0f),
        glm::vec3(0.0f, -1.0f, 0.0f),
        glm::vec3(0.0f, 0.0f, 1.0f),
        glm::vec3(0.0f, 0.0f, -1.0f),
    };
    for (const auto& offset : offsets)
    {
        const ChunkCenter cc = posToChunkCenter(block_pos + offset);
        if (isChunkActive(cc))
        {
            activeChunks[cc]->removeBlock(block_pos);
            runChunkLoadedCallbacks(*activeChunks[cc]);
        }
    }
}

void World::addChunkLoadedCallback(const std::function<void(const Chunk&)>& callback)
{
    chunkLoadedCallbacks.push_back(callback);
}

void World::clearChunkLoadedCallbacks()
{
    chunkLoadedCallbacks.clear();
}

void World::addChunkUnloadedCallback(const std::function<void(const Chunk&)>& callback)
{
    chunkUnloadedCallbacks.push_back(callback);
}

void World::clearChunkUnloadedCallbacks()
{
    chunkUnloadedCallbacks.clear();
}

const std::vector<Chunk*> World::getActiveChunks() const
{
    std::vector<Chunk*> chunks;
    chunks.reserve(activeChunks.size());
    for (const auto& chunk : activeChunks)
    {
        chunks.push_back(chunk.second);
    }
    return chunks;
}

const Model World::getModel() const
{
    std::vector<Model::Vertex> vertices;
    std::vector<Model::Index> indices;
    size_t vertices_size = 0;
    size_t indices_size = 0;
    for (const auto& chunk_info : activeChunks)
    {
        const Model& chunk_model = chunk_info.second->getModel();
        vertices_size += chunk_model.getVertices().size();
        indices_size += chunk_model.getIndices().size();
    }
    vertices.reserve(vertices_size);
    indices.reserve(indices_size);
    Model::Index accum = 0;
    for (const auto& chunk_info : activeChunks)
    {
        const Model& chunk_model = chunk_info.second->getModel();

        const auto& chunk_vertices = chunk_model.getVertices();
        vertices.insert(vertices.end(), chunk_vertices.begin(), chunk_vertices.end());

        std::vector<Model::Index> chunk_indices = chunk_model.getIndices();
        for (auto& chunk_index : chunk_indices)
        {
            chunk_index += accum;
        }
        indices.insert(indices.end(), chunk_indices.begin(), chunk_indices.end());
        accum += static_cast<Model::Index>(chunk_vertices.size());
    }

    return Model(vertices, indices);
}
